# Patia
Exercises and Planner for PATIA course

L'idée du plannificateur est la suivante, à l'aide de la méthode 'instantiate' fournis par PDDL4J, nous obtenons un problème grounded ce qui nous permet à l'aide méthodes comme .getActions() de récupérer nos différentes propositions. Nous mappons ensuite chacune des propositions à un entier unique. Puis nous donnons chacunes des clauses sous la forme {1, 2, -3} qui signifie par exemple que soit les prépositions 1 ou 2 sont vrai soit la 3 est fausses. Nous ajoutons ensuite nos clauses dans le solver SAT4J qui s'occupe ensuite de résoudre l'ensemble des clauses et de nous renvoyer une liste de proposition qui deuvent être vrai (un model stable). 
Nos propositions sont encodées sous la forme d'action pour un temps T. En effet l'action : moove(a,b) au temps 0 est différentes de moove(a,b) au temps 2. De cette manière l'entier 1 et l'entier 2 peuvent représenter la même action mais à un temps T différent. Des contraintes seront donc rajouté de manière à s'assurer qu'une seule et unique action peut être effectué pour chaque T=i. De cette manière, le résultat donner par SAT4J sera une liste d'actions liées chacune pour un temps T différent et nous pourrons transformer celle-ci en un plan : Action a à T=0, Action a2 à T=1, etc.
Le plan reconstruit, celui-ci est testé et si celui-ci est bien un plan cohérent, il est retransformé en plan textuel (de a1, a2, à : moove(a,b), place(c,d)), puis affiché à l'utilisateur de notre planificateur.
